import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const runtime = 'nodejs';

function autoReply(customerText: string) {
  const t = (customerText || '').toLowerCase();
  if (t.includes('return')) return 'Returns are accepted within 30 days if items are unworn with tags. Want the return steps?';
  if (t.includes('ship') || t.includes('delivery')) return 'Orders ship in 1–2 business days. Typical US delivery is 3–7 business days. What’s your ZIP code?';
  if (t.includes('order') || t.includes('tracking')) return 'I can help—please share your order number and the email used at checkout so I can check the status.';
  if (t.includes('xl') || t.includes('size')) return 'I can help with sizing. Which item is it, and what size do you usually wear?';
  return 'Got it. Can you share a little more detail so I can help faster?';
}

function subjectFrom(text: string) {
  const t = (text || '').toLowerCase();
  if (t.includes('return')) return 'Return policy';
  if (t.includes('ship') || t.includes('delivery')) return 'Shipping time';
  if (t.includes('order') || t.includes('tracking')) return 'Order status';
  if (t.includes('size') || t.includes('xl')) return 'Sizing / availability';
  return 'Customer question';
}

export async function POST(req: Request) {
  const body: any = await req.json().catch(() => ({}));

  const tenantSlug = typeof body.tenantSlug === 'string' ? body.tenantSlug.trim() : '';
  const customerName = typeof body.customerName === 'string' ? body.customerName.trim() : 'Web shopper';
  const text = typeof body.text === 'string' ? body.text.trim() : '';
  const conversationId = typeof body.conversationId === 'string' ? body.conversationId.trim() : '';

  if (!tenantSlug) return NextResponse.json({ ok: false, error: 'Missing tenantSlug' }, { status: 400 });
  if (!text) return NextResponse.json({ ok: false, error: 'Empty message' }, { status: 400 });

  const tenant = await prisma.tenant.findUnique({ where: { slug: tenantSlug } });
  if (!tenant) return NextResponse.json({ ok: false, error: 'Tenant not found' }, { status: 404 });

  let convo =
    conversationId
      ? await prisma.conversation.findFirst({ where: { id: conversationId, tenantId: tenant.id } })
      : null;

  if (!convo) {
    convo = await prisma.conversation.create({
      data: {
        tenantId: tenant.id,
        customerName,
        subject: subjectFrom(text),
        status: 'open',
        channel: 'web',
        tags: '',
        aiEnabled: true,
        lastMessageAt: new Date(),
      },
    });
  }

  await prisma.message.create({
    data: { conversationId: convo.id, role: 'customer', content: text },
  });

  await prisma.conversation.update({
    where: { id: convo.id },
    data: { lastMessageAt: new Date() },
  });

  let assistant: string | null = null;
  if (convo.aiEnabled) {
    assistant = autoReply(text);
    await prisma.message.create({
      data: { conversationId: convo.id, role: 'assistant', content: assistant },
    });
    await prisma.conversation.update({
      where: { id: convo.id },
      data: { lastMessageAt: new Date() },
    });
  }

  const full = await prisma.conversation.findUnique({
    where: { id: convo.id },
    include: { messages: { orderBy: { createdAt: 'asc' }, take: 50 } },
  });

  return NextResponse.json({
    ok: true,
    conversationId: convo.id,
    assistant,
    messages: (full?.messages ?? []).map((m) => ({
      id: m.id,
      role: m.role,
      content: m.content,
      createdAt: m.createdAt,
    })),
  });
}
