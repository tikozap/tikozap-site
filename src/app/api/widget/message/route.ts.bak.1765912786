import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getAuthedUserAndTenant } from '@/lib/auth';

export const runtime = 'nodejs';

function assistantAutoReply(customerText: string) {
  const t = (customerText || '').toLowerCase();
  if (t.includes('return')) return 'Returns are accepted within 30 days if items are unworn with tags. Want me to outline the return steps?';
  if (t.includes('ship') || t.includes('delivery')) return 'Orders ship in 1–2 business days. Typical US delivery is 3–7 business days. What’s your ZIP code?';
  if (t.includes('order') || t.includes('tracking')) return 'I can help—please share your order number and the email used at checkout so I can check the status.';
  if (t.includes('xl') || t.includes('size')) return 'I can help with sizing. Which item are you looking at, and what size do you usually wear?';
  return 'Got it. Can you share a little more detail so I can help faster?';
}

export async function POST(req: Request) {
  try {
    const body: any = await req.json().catch(() => ({}));

    const text = (body?.text || '').toString().trim();
    if (!text) return NextResponse.json({ ok: false, error: 'Missing text' }, { status: 400 });

    // Preferred: if the user is logged into the dashboard, use authed tenant.
    const auth = await getAuthedUserAndTenant().catch(() => null as any);

    // Fallback (demo): allow a tenantSlug, resolve tenant by slug.
    const tenantSlug = (body?.tenantSlug || '').toString().trim();

    let tenantId: string | null = auth?.tenant?.id ?? null;

    if (!tenantId) {
      if (!tenantSlug) return NextResponse.json({ ok: false, error: 'Missing tenantSlug' }, { status: 400 });

      // tolerate model casing
      const p: any = prisma as any;
      const tenantModel =
        p.tenant ?? p.Tenant ??
        p.workspace ?? p.Workspace ??
        p.merchant ?? p.Merchant;

      if (!tenantModel?.findUnique) {
        return NextResponse.json({ ok: false, error: 'No tenant model found in Prisma client.' }, { status: 500 });
      }

      const tenant = await tenantModel.findUnique({ where: { slug: tenantSlug } });
      if (!tenant?.id) {
        return NextResponse.json({ ok: false, error: 'Tenant not found for tenantSlug.' }, { status: 404 });
      }
      tenantId = tenant.id;
    }

    const customerName = (body?.customerName || 'Sophia').toString().trim() || 'Sophia';
    const channel = (body?.channel || 'web').toString().trim() || 'web';
    const subject = (body?.subject || 'Widget test').toString().trim() || 'Widget test';
    const aiEnabled = body?.aiEnabled === false ? false : true;

    let conversationId = (body?.conversationId || '').toString().trim();

    // Create new conversation if needed
    if (!conversationId) {
      const convo = await prisma.conversation.create({
        data: {
          tenantId,
          customerName,
          subject,
          status: aiEnabled ? 'open' : 'waiting',
          channel,
          tags: (body?.tags || '').toString(),
          aiEnabled,
          lastMessageAt: new Date(),
        },
        select: { id: true },
      });
      conversationId = convo.id;
    }

    // Append customer message
    await prisma.message.create({
      data: {
        conversationId,
        role: 'customer',
        content: text,
      },
    });

    // Optional assistant auto-reply (keeps test UX snappy)
    if (allowAi) {
      await prisma.message.create({
        data: {
          conversationId,
          role: 'assistant',
          content: assistantAutoReply(text),
        },
      });
    }

    // Keep conversation fresh
    await prisma.conversation.update({
      where: { id: conversationId },
      data: { lastMessageAt: new Date() },
    });

    const messages = await prisma.message.findMany({
      where: { conversationId },
      orderBy: { createdAt: 'asc' },
      select: { id: true, role: true, content: true, createdAt: true },
    });

    return NextResponse.json({ ok: true, conversationId, messages });
  } catch (err: any) {
    console.error('[widget/message] error', err);
    return NextResponse.json(
      { ok: false, error: err?.message || 'widget message failed' },
      { status: 500 }
    );
  }
}
