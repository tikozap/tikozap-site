// src/app/api/demo-login/route.ts
import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { randomUUID } from 'crypto';
import { prisma } from '@/lib/prisma';
import { getAuthedUserAndTenant } from '@/lib/auth';

export const runtime = 'nodejs';

function tenantDisplayName(t: any) {
  return (
    (t && (('storeName' in t && t.storeName) || ('name' in t && t.name))) ||
    t?.slug ||
    'Your store'
  );
}

// GET -> check current session + return widget publicKey
export async function GET() {
  const auth = await getAuthedUserAndTenant();
  if (!auth) return NextResponse.json({ ok: false }, { status: 401, headers: { 'cache-control': 'no-store' } });

  const tenantName = tenantDisplayName(auth.tenant);

  const widget = await prisma.widget.findUnique({
    where: { tenantId: auth.tenant.id },
    select: {
      publicKey: true,
      enabled: true,
      assistantName: true,
      greeting: true,
      brandColor: true,
      installedAt: true,
    },
  });

  return NextResponse.json(
    {
      ok: true,
      tenant: {
        id: auth.tenant.id,
        slug: auth.tenant.slug,
        name: tenantName,
        storeName: tenantName,
      },
      widget,
    },
    { headers: { 'cache-control': 'no-store' } }
  );
}

// POST -> create/reuse demo user + tenant, ensure widget exists/enabled, return publicKey
export async function POST() {
  const demoEmail = 'demo-merchant@tikozap.test';

  const user = await prisma.user.upsert({
    where: { email: demoEmail },
    update: {},
    create: { email: demoEmail, name: 'Demo Merchant' },
  });

  const tenant = await prisma.tenant.upsert({
    where: { slug: 'three-tree-fashion' },
    update: { owner: { connect: { id: user.id } } },
    create: {
      slug: 'three-tree-fashion',
      storeName: 'Three Tree Fashion',
      owner: { connect: { id: user.id } },
    },
  });

  await prisma.membership.upsert({
    where: { userId_tenantId: { userId: user.id, tenantId: tenant.id } },
    update: { role: 'owner' },
    create: { userId: user.id, tenantId: tenant.id, role: 'owner' },
  });

  // IMPORTANT: do NOT overwrite publicKey on update; only set on create (default cuid()).
// Create/update Widget (THIS is what /api/widget/public/settings reads)
let widget = await prisma.widget.upsert({
  where: { tenantId: tenant.id },
  update: {
    enabled: true,
    assistantName: "Three Tree Assistant",
    greeting: "Hi! How can I help today?",
    brandColor: "#111827",
    installedAt: new Date(),
  },
  create: {
    tenantId: tenant.id,
    enabled: true,
    assistantName: "Three Tree Assistant",
    greeting: "Hi! How can I help today?",
    brandColor: "#111827",
    installedAt: new Date(),
    // publicKey will be generated by @default(cuid()) automatically
  },
});

// 2) one-time repair: if publicKey was previously overwritten to tenantId, rotate it once
if (widget.publicKey === widget.tenantId) {
  const newKey = "tz_" + randomUUID().replace(/-/g, "");
  widget = await prisma.widget.update({
    where: { tenantId: tenant.id },
    data: { publicKey: newKey },
    select: {
      publicKey: true,
      enabled: true,
      assistantName: true,
      greeting: true,
      brandColor: true,
      installedAt: true,
      tenantId: true,
    },
  });
}

  const token = randomUUID();
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

  await prisma.session.create({
    data: { token, userId: user.id, expiresAt },
  });

  const jar = cookies();
  jar.set('tz_session', token, {
    httpOnly: true,
    path: '/',
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    expires: expiresAt,
  });
  jar.set('tz_tenant', tenant.id, {
    httpOnly: true,
    path: '/',
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    expires: expiresAt,
  });

  const tenantName = tenant.storeName || tenant.slug || 'Your store';

return NextResponse.json({
  ok: true,
  tenant: { id: tenant.id, slug: tenant.slug, name: tenant.storeName, storeName: tenant.storeName },
  widget,
  widgetPublicKey: widget.publicKey,
});
}
